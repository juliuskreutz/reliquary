// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `SceneGadgetInfo.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:SceneGadgetInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneGadgetInfo {
    // message fields
    // @@protoc_insertion_point(field:SceneGadgetInfo.gadget_id)
    pub gadget_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.group_id)
    pub group_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.config_id)
    pub config_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.owner_entity_id)
    pub owner_entity_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.born_type)
    pub born_type: ::protobuf::EnumOrUnknown<super::GadgetBornType::GadgetBornType>,
    // @@protoc_insertion_point(field:SceneGadgetInfo.gadget_state)
    pub gadget_state: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.KPKNNJLPMFP)
    pub KPKNNJLPMFP: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.is_show_cutscene)
    pub is_show_cutscene: bool,
    // @@protoc_insertion_point(field:SceneGadgetInfo.authority_peer_id)
    pub authority_peer_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.is_enable_interact)
    pub is_enable_interact: bool,
    // @@protoc_insertion_point(field:SceneGadgetInfo.CLICILNBKDD)
    pub CLICILNBKDD: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.mark_flag)
    pub mark_flag: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.prop_owner_entity_id)
    pub prop_owner_entity_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.platform)
    pub platform: ::protobuf::MessageField<super::PlatformInfo::PlatformInfo>,
    // @@protoc_insertion_point(field:SceneGadgetInfo.interact_uid_list)
    pub interact_uid_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SceneGadgetInfo.draft_id)
    pub draft_id: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.KHICBPFFAII)
    pub KHICBPFFAII: u32,
    // @@protoc_insertion_point(field:SceneGadgetInfo.play_info)
    pub play_info: ::protobuf::MessageField<super::GadgetPlayInfo::GadgetPlayInfo>,
    // message oneof groups
    pub content: ::std::option::Option<scene_gadget_info::Content>,
    // special fields
    // @@protoc_insertion_point(special_field:SceneGadgetInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneGadgetInfo {
    fn default() -> &'a SceneGadgetInfo {
        <SceneGadgetInfo as ::protobuf::Message>::default_instance()
    }
}

impl SceneGadgetInfo {
    pub fn new() -> SceneGadgetInfo {
        ::std::default::Default::default()
    }

    // .GatherGadgetInfo gather_gadget = 13;

    pub fn gather_gadget(&self) -> &super::GatherGadgetInfo::GatherGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(ref v)) => v,
            _ => <super::GatherGadgetInfo::GatherGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_gather_gadget(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_gather_gadget(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gather_gadget(&mut self, v: super::GatherGadgetInfo::GatherGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gather_gadget(&mut self) -> &mut super::GatherGadgetInfo::GatherGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(super::GatherGadgetInfo::GatherGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gather_gadget(&mut self) -> super::GatherGadgetInfo::GatherGadgetInfo {
        if self.has_gather_gadget() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GatherGadgetInfo::GatherGadgetInfo::new()
        }
    }

    // .WorktopInfo worktop = 14;

    pub fn worktop(&self) -> &super::WorktopInfo::WorktopInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::Worktop(ref v)) => v,
            _ => <super::WorktopInfo::WorktopInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_worktop(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worktop(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::Worktop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worktop(&mut self, v: super::WorktopInfo::WorktopInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::Worktop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worktop(&mut self) -> &mut super::WorktopInfo::WorktopInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::Worktop(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::Worktop(super::WorktopInfo::WorktopInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::Worktop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worktop(&mut self) -> super::WorktopInfo::WorktopInfo {
        if self.has_worktop() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::Worktop(v)) => v,
                _ => panic!(),
            }
        } else {
            super::WorktopInfo::WorktopInfo::new()
        }
    }

    // .ClientGadgetInfo client_gadget = 15;

    pub fn client_gadget(&self) -> &super::ClientGadgetInfo::ClientGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(ref v)) => v,
            _ => <super::ClientGadgetInfo::ClientGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_client_gadget(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_client_gadget(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_client_gadget(&mut self, v: super::ClientGadgetInfo::ClientGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_client_gadget(&mut self) -> &mut super::ClientGadgetInfo::ClientGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(super::ClientGadgetInfo::ClientGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_client_gadget(&mut self) -> super::ClientGadgetInfo::ClientGadgetInfo {
        if self.has_client_gadget() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ClientGadgetInfo::ClientGadgetInfo::new()
        }
    }

    // .WeatherInfo weather = 17;

    pub fn weather(&self) -> &super::WeatherInfo::WeatherInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::Weather(ref v)) => v,
            _ => <super::WeatherInfo::WeatherInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_weather(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_weather(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::Weather(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_weather(&mut self, v: super::WeatherInfo::WeatherInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::Weather(v))
    }

    // Mutable pointer to the field.
    pub fn mut_weather(&mut self) -> &mut super::WeatherInfo::WeatherInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::Weather(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::Weather(super::WeatherInfo::WeatherInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::Weather(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_weather(&mut self) -> super::WeatherInfo::WeatherInfo {
        if self.has_weather() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::Weather(v)) => v,
                _ => panic!(),
            }
        } else {
            super::WeatherInfo::WeatherInfo::new()
        }
    }

    // .AbilityGadgetInfo ability_gadget = 18;

    pub fn ability_gadget(&self) -> &super::AbilityGadgetInfo::AbilityGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(ref v)) => v,
            _ => <super::AbilityGadgetInfo::AbilityGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ability_gadget(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_ability_gadget(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ability_gadget(&mut self, v: super::AbilityGadgetInfo::AbilityGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ability_gadget(&mut self) -> &mut super::AbilityGadgetInfo::AbilityGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(super::AbilityGadgetInfo::AbilityGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ability_gadget(&mut self) -> super::AbilityGadgetInfo::AbilityGadgetInfo {
        if self.has_ability_gadget() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(v)) => v,
                _ => panic!(),
            }
        } else {
            super::AbilityGadgetInfo::AbilityGadgetInfo::new()
        }
    }

    // .StatueGadgetInfo statue_gadget = 19;

    pub fn statue_gadget(&self) -> &super::StatueGadgetInfo::StatueGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(ref v)) => v,
            _ => <super::StatueGadgetInfo::StatueGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_statue_gadget(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_statue_gadget(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_statue_gadget(&mut self, v: super::StatueGadgetInfo::StatueGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_statue_gadget(&mut self) -> &mut super::StatueGadgetInfo::StatueGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(super::StatueGadgetInfo::StatueGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_statue_gadget(&mut self) -> super::StatueGadgetInfo::StatueGadgetInfo {
        if self.has_statue_gadget() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(v)) => v,
                _ => panic!(),
            }
        } else {
            super::StatueGadgetInfo::StatueGadgetInfo::new()
        }
    }

    // .BossChestInfo boss_chest = 20;

    pub fn boss_chest(&self) -> &super::BossChestInfo::BossChestInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::BossChest(ref v)) => v,
            _ => <super::BossChestInfo::BossChestInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_boss_chest(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_boss_chest(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::BossChest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boss_chest(&mut self, v: super::BossChestInfo::BossChestInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::BossChest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_boss_chest(&mut self) -> &mut super::BossChestInfo::BossChestInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::BossChest(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::BossChest(super::BossChestInfo::BossChestInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::BossChest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_boss_chest(&mut self) -> super::BossChestInfo::BossChestInfo {
        if self.has_boss_chest() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::BossChest(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BossChestInfo::BossChestInfo::new()
        }
    }

    // .BlossomChestInfo blossom_chest = 41;

    pub fn blossom_chest(&self) -> &super::BlossomChestInfo::BlossomChestInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(ref v)) => v,
            _ => <super::BlossomChestInfo::BlossomChestInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_blossom_chest(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_blossom_chest(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_blossom_chest(&mut self, v: super::BlossomChestInfo::BlossomChestInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_blossom_chest(&mut self) -> &mut super::BlossomChestInfo::BlossomChestInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(super::BlossomChestInfo::BlossomChestInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_blossom_chest(&mut self) -> super::BlossomChestInfo::BlossomChestInfo {
        if self.has_blossom_chest() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BlossomChestInfo::BlossomChestInfo::new()
        }
    }

    // .MpPlayRewardInfo mp_play_reward = 42;

    pub fn mp_play_reward(&self) -> &super::MpPlayRewardInfo::MpPlayRewardInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(ref v)) => v,
            _ => <super::MpPlayRewardInfo::MpPlayRewardInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mp_play_reward(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_mp_play_reward(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mp_play_reward(&mut self, v: super::MpPlayRewardInfo::MpPlayRewardInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mp_play_reward(&mut self) -> &mut super::MpPlayRewardInfo::MpPlayRewardInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(super::MpPlayRewardInfo::MpPlayRewardInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mp_play_reward(&mut self) -> super::MpPlayRewardInfo::MpPlayRewardInfo {
        if self.has_mp_play_reward() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(v)) => v,
                _ => panic!(),
            }
        } else {
            super::MpPlayRewardInfo::MpPlayRewardInfo::new()
        }
    }

    // .GadgetGeneralRewardInfo general_reward = 43;

    pub fn general_reward(&self) -> &super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(ref v)) => v,
            _ => <super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_general_reward(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_general_reward(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_general_reward(&mut self, v: super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(v))
    }

    // Mutable pointer to the field.
    pub fn mut_general_reward(&mut self) -> &mut super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_general_reward(&mut self) -> super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo {
        if self.has_general_reward() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo::new()
        }
    }

    // .OfferingInfo offering_info = 44;

    pub fn offering_info(&self) -> &super::OfferingInfo::OfferingInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(ref v)) => v,
            _ => <super::OfferingInfo::OfferingInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_offering_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_offering_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offering_info(&mut self, v: super::OfferingInfo::OfferingInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_offering_info(&mut self) -> &mut super::OfferingInfo::OfferingInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(super::OfferingInfo::OfferingInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offering_info(&mut self) -> super::OfferingInfo::OfferingInfo {
        if self.has_offering_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::OfferingInfo::OfferingInfo::new()
        }
    }

    // .FoundationInfo foundation_info = 45;

    pub fn foundation_info(&self) -> &super::FoundationInfo::FoundationInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(ref v)) => v,
            _ => <super::FoundationInfo::FoundationInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_foundation_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_foundation_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foundation_info(&mut self, v: super::FoundationInfo::FoundationInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foundation_info(&mut self) -> &mut super::FoundationInfo::FoundationInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(super::FoundationInfo::FoundationInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foundation_info(&mut self) -> super::FoundationInfo::FoundationInfo {
        if self.has_foundation_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FoundationInfo::FoundationInfo::new()
        }
    }

    // .VehicleInfo vehicle_info = 46;

    pub fn vehicle_info(&self) -> &super::VehicleInfo::VehicleInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(ref v)) => v,
            _ => <super::VehicleInfo::VehicleInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vehicle_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_vehicle_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vehicle_info(&mut self, v: super::VehicleInfo::VehicleInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vehicle_info(&mut self) -> &mut super::VehicleInfo::VehicleInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(super::VehicleInfo::VehicleInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vehicle_info(&mut self) -> super::VehicleInfo::VehicleInfo {
        if self.has_vehicle_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::VehicleInfo::VehicleInfo::new()
        }
    }

    // .EchoShellInfo shell_info = 47;

    pub fn shell_info(&self) -> &super::EchoShellInfo::EchoShellInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(ref v)) => v,
            _ => <super::EchoShellInfo::EchoShellInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_shell_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_shell_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shell_info(&mut self, v: super::EchoShellInfo::EchoShellInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shell_info(&mut self) -> &mut super::EchoShellInfo::EchoShellInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(super::EchoShellInfo::EchoShellInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shell_info(&mut self) -> super::EchoShellInfo::EchoShellInfo {
        if self.has_shell_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EchoShellInfo::EchoShellInfo::new()
        }
    }

    // .ScreenInfo screen_info = 48;

    pub fn screen_info(&self) -> &super::ScreenInfo::ScreenInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(ref v)) => v,
            _ => <super::ScreenInfo::ScreenInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_screen_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_screen_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_screen_info(&mut self, v: super::ScreenInfo::ScreenInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_screen_info(&mut self) -> &mut super::ScreenInfo::ScreenInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(super::ScreenInfo::ScreenInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_screen_info(&mut self) -> super::ScreenInfo::ScreenInfo {
        if self.has_screen_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ScreenInfo::ScreenInfo::new()
        }
    }

    // .FishPoolInfo fish_pool_info = 59;

    pub fn fish_pool_info(&self) -> &super::FishPoolInfo::FishPoolInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(ref v)) => v,
            _ => <super::FishPoolInfo::FishPoolInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fish_pool_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_fish_pool_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fish_pool_info(&mut self, v: super::FishPoolInfo::FishPoolInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fish_pool_info(&mut self) -> &mut super::FishPoolInfo::FishPoolInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(super::FishPoolInfo::FishPoolInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fish_pool_info(&mut self) -> super::FishPoolInfo::FishPoolInfo {
        if self.has_fish_pool_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FishPoolInfo::FishPoolInfo::new()
        }
    }

    // .CustomGadgetTreeInfo custom_gadget_tree_info = 60;

    pub fn custom_gadget_tree_info(&self) -> &super::CustomGadgetTreeInfo::CustomGadgetTreeInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(ref v)) => v,
            _ => <super::CustomGadgetTreeInfo::CustomGadgetTreeInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_custom_gadget_tree_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_custom_gadget_tree_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom_gadget_tree_info(&mut self, v: super::CustomGadgetTreeInfo::CustomGadgetTreeInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom_gadget_tree_info(&mut self) -> &mut super::CustomGadgetTreeInfo::CustomGadgetTreeInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(super::CustomGadgetTreeInfo::CustomGadgetTreeInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom_gadget_tree_info(&mut self) -> super::CustomGadgetTreeInfo::CustomGadgetTreeInfo {
        if self.has_custom_gadget_tree_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CustomGadgetTreeInfo::CustomGadgetTreeInfo::new()
        }
    }

    // .RoguelikeGadgetInfo roguelike_gadget_info = 61;

    pub fn roguelike_gadget_info(&self) -> &super::RoguelikeGadgetInfo::RoguelikeGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(ref v)) => v,
            _ => <super::RoguelikeGadgetInfo::RoguelikeGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_roguelike_gadget_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_roguelike_gadget_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_roguelike_gadget_info(&mut self, v: super::RoguelikeGadgetInfo::RoguelikeGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_roguelike_gadget_info(&mut self) -> &mut super::RoguelikeGadgetInfo::RoguelikeGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(super::RoguelikeGadgetInfo::RoguelikeGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_roguelike_gadget_info(&mut self) -> super::RoguelikeGadgetInfo::RoguelikeGadgetInfo {
        if self.has_roguelike_gadget_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::RoguelikeGadgetInfo::RoguelikeGadgetInfo::new()
        }
    }

    // .NightCrowGadgetInfo night_crow_gadget_info = 62;

    pub fn night_crow_gadget_info(&self) -> &super::NightCrowGadgetInfo::NightCrowGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(ref v)) => v,
            _ => <super::NightCrowGadgetInfo::NightCrowGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_night_crow_gadget_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_night_crow_gadget_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_night_crow_gadget_info(&mut self, v: super::NightCrowGadgetInfo::NightCrowGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_night_crow_gadget_info(&mut self) -> &mut super::NightCrowGadgetInfo::NightCrowGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(super::NightCrowGadgetInfo::NightCrowGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_night_crow_gadget_info(&mut self) -> super::NightCrowGadgetInfo::NightCrowGadgetInfo {
        if self.has_night_crow_gadget_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NightCrowGadgetInfo::NightCrowGadgetInfo::new()
        }
    }

    // .DeshretObeliskGadgetInfo deshret_obelisk_gadget_info = 63;

    pub fn deshret_obelisk_gadget_info(&self) -> &super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(ref v)) => v,
            _ => <super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_deshret_obelisk_gadget_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_deshret_obelisk_gadget_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deshret_obelisk_gadget_info(&mut self, v: super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_deshret_obelisk_gadget_info(&mut self) -> &mut super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deshret_obelisk_gadget_info(&mut self) -> super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo {
        if self.has_deshret_obelisk_gadget_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo::new()
        }
    }

    // .CoinCollectOperatorInfo coin_collect_operator_info = 64;

    pub fn coin_collect_operator_info(&self) -> &super::CoinCollectOperatorInfo::CoinCollectOperatorInfo {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(ref v)) => v,
            _ => <super::CoinCollectOperatorInfo::CoinCollectOperatorInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_coin_collect_operator_info(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_coin_collect_operator_info(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_coin_collect_operator_info(&mut self, v: super::CoinCollectOperatorInfo::CoinCollectOperatorInfo) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_coin_collect_operator_info(&mut self) -> &mut super::CoinCollectOperatorInfo::CoinCollectOperatorInfo {
        if let ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(super::CoinCollectOperatorInfo::CoinCollectOperatorInfo::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_coin_collect_operator_info(&mut self) -> super::CoinCollectOperatorInfo::CoinCollectOperatorInfo {
        if self.has_coin_collect_operator_info() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CoinCollectOperatorInfo::CoinCollectOperatorInfo::new()
        }
    }

    // .TrifleGadget trifle_gadget = 67;

    pub fn trifle_gadget(&self) -> &super::TrifleGadget::TrifleGadget {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(ref v)) => v,
            _ => <super::TrifleGadget::TrifleGadget as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_trifle_gadget(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_trifle_gadget(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trifle_gadget(&mut self, v: super::TrifleGadget::TrifleGadget) {
        self.content = ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trifle_gadget(&mut self) -> &mut super::TrifleGadget::TrifleGadget {
        if let ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(super::TrifleGadget::TrifleGadget::new()));
        }
        match self.content {
            ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trifle_gadget(&mut self) -> super::TrifleGadget::TrifleGadget {
        if self.has_trifle_gadget() {
            match self.content.take() {
                ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TrifleGadget::TrifleGadget::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(40);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gadget_id",
            |m: &SceneGadgetInfo| { &m.gadget_id },
            |m: &mut SceneGadgetInfo| { &mut m.gadget_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &SceneGadgetInfo| { &m.group_id },
            |m: &mut SceneGadgetInfo| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "config_id",
            |m: &SceneGadgetInfo| { &m.config_id },
            |m: &mut SceneGadgetInfo| { &mut m.config_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_entity_id",
            |m: &SceneGadgetInfo| { &m.owner_entity_id },
            |m: &mut SceneGadgetInfo| { &mut m.owner_entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "born_type",
            |m: &SceneGadgetInfo| { &m.born_type },
            |m: &mut SceneGadgetInfo| { &mut m.born_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gadget_state",
            |m: &SceneGadgetInfo| { &m.gadget_state },
            |m: &mut SceneGadgetInfo| { &mut m.gadget_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KPKNNJLPMFP",
            |m: &SceneGadgetInfo| { &m.KPKNNJLPMFP },
            |m: &mut SceneGadgetInfo| { &mut m.KPKNNJLPMFP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_show_cutscene",
            |m: &SceneGadgetInfo| { &m.is_show_cutscene },
            |m: &mut SceneGadgetInfo| { &mut m.is_show_cutscene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "authority_peer_id",
            |m: &SceneGadgetInfo| { &m.authority_peer_id },
            |m: &mut SceneGadgetInfo| { &mut m.authority_peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_enable_interact",
            |m: &SceneGadgetInfo| { &m.is_enable_interact },
            |m: &mut SceneGadgetInfo| { &mut m.is_enable_interact },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CLICILNBKDD",
            |m: &SceneGadgetInfo| { &m.CLICILNBKDD },
            |m: &mut SceneGadgetInfo| { &mut m.CLICILNBKDD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GatherGadgetInfo::GatherGadgetInfo>(
            "gather_gadget",
            SceneGadgetInfo::has_gather_gadget,
            SceneGadgetInfo::gather_gadget,
            SceneGadgetInfo::mut_gather_gadget,
            SceneGadgetInfo::set_gather_gadget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::WorktopInfo::WorktopInfo>(
            "worktop",
            SceneGadgetInfo::has_worktop,
            SceneGadgetInfo::worktop,
            SceneGadgetInfo::mut_worktop,
            SceneGadgetInfo::set_worktop,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ClientGadgetInfo::ClientGadgetInfo>(
            "client_gadget",
            SceneGadgetInfo::has_client_gadget,
            SceneGadgetInfo::client_gadget,
            SceneGadgetInfo::mut_client_gadget,
            SceneGadgetInfo::set_client_gadget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::WeatherInfo::WeatherInfo>(
            "weather",
            SceneGadgetInfo::has_weather,
            SceneGadgetInfo::weather,
            SceneGadgetInfo::mut_weather,
            SceneGadgetInfo::set_weather,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AbilityGadgetInfo::AbilityGadgetInfo>(
            "ability_gadget",
            SceneGadgetInfo::has_ability_gadget,
            SceneGadgetInfo::ability_gadget,
            SceneGadgetInfo::mut_ability_gadget,
            SceneGadgetInfo::set_ability_gadget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::StatueGadgetInfo::StatueGadgetInfo>(
            "statue_gadget",
            SceneGadgetInfo::has_statue_gadget,
            SceneGadgetInfo::statue_gadget,
            SceneGadgetInfo::mut_statue_gadget,
            SceneGadgetInfo::set_statue_gadget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BossChestInfo::BossChestInfo>(
            "boss_chest",
            SceneGadgetInfo::has_boss_chest,
            SceneGadgetInfo::boss_chest,
            SceneGadgetInfo::mut_boss_chest,
            SceneGadgetInfo::set_boss_chest,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BlossomChestInfo::BlossomChestInfo>(
            "blossom_chest",
            SceneGadgetInfo::has_blossom_chest,
            SceneGadgetInfo::blossom_chest,
            SceneGadgetInfo::mut_blossom_chest,
            SceneGadgetInfo::set_blossom_chest,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::MpPlayRewardInfo::MpPlayRewardInfo>(
            "mp_play_reward",
            SceneGadgetInfo::has_mp_play_reward,
            SceneGadgetInfo::mp_play_reward,
            SceneGadgetInfo::mut_mp_play_reward,
            SceneGadgetInfo::set_mp_play_reward,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo>(
            "general_reward",
            SceneGadgetInfo::has_general_reward,
            SceneGadgetInfo::general_reward,
            SceneGadgetInfo::mut_general_reward,
            SceneGadgetInfo::set_general_reward,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::OfferingInfo::OfferingInfo>(
            "offering_info",
            SceneGadgetInfo::has_offering_info,
            SceneGadgetInfo::offering_info,
            SceneGadgetInfo::mut_offering_info,
            SceneGadgetInfo::set_offering_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FoundationInfo::FoundationInfo>(
            "foundation_info",
            SceneGadgetInfo::has_foundation_info,
            SceneGadgetInfo::foundation_info,
            SceneGadgetInfo::mut_foundation_info,
            SceneGadgetInfo::set_foundation_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::VehicleInfo::VehicleInfo>(
            "vehicle_info",
            SceneGadgetInfo::has_vehicle_info,
            SceneGadgetInfo::vehicle_info,
            SceneGadgetInfo::mut_vehicle_info,
            SceneGadgetInfo::set_vehicle_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EchoShellInfo::EchoShellInfo>(
            "shell_info",
            SceneGadgetInfo::has_shell_info,
            SceneGadgetInfo::shell_info,
            SceneGadgetInfo::mut_shell_info,
            SceneGadgetInfo::set_shell_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ScreenInfo::ScreenInfo>(
            "screen_info",
            SceneGadgetInfo::has_screen_info,
            SceneGadgetInfo::screen_info,
            SceneGadgetInfo::mut_screen_info,
            SceneGadgetInfo::set_screen_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FishPoolInfo::FishPoolInfo>(
            "fish_pool_info",
            SceneGadgetInfo::has_fish_pool_info,
            SceneGadgetInfo::fish_pool_info,
            SceneGadgetInfo::mut_fish_pool_info,
            SceneGadgetInfo::set_fish_pool_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::CustomGadgetTreeInfo::CustomGadgetTreeInfo>(
            "custom_gadget_tree_info",
            SceneGadgetInfo::has_custom_gadget_tree_info,
            SceneGadgetInfo::custom_gadget_tree_info,
            SceneGadgetInfo::mut_custom_gadget_tree_info,
            SceneGadgetInfo::set_custom_gadget_tree_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::RoguelikeGadgetInfo::RoguelikeGadgetInfo>(
            "roguelike_gadget_info",
            SceneGadgetInfo::has_roguelike_gadget_info,
            SceneGadgetInfo::roguelike_gadget_info,
            SceneGadgetInfo::mut_roguelike_gadget_info,
            SceneGadgetInfo::set_roguelike_gadget_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NightCrowGadgetInfo::NightCrowGadgetInfo>(
            "night_crow_gadget_info",
            SceneGadgetInfo::has_night_crow_gadget_info,
            SceneGadgetInfo::night_crow_gadget_info,
            SceneGadgetInfo::mut_night_crow_gadget_info,
            SceneGadgetInfo::set_night_crow_gadget_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo>(
            "deshret_obelisk_gadget_info",
            SceneGadgetInfo::has_deshret_obelisk_gadget_info,
            SceneGadgetInfo::deshret_obelisk_gadget_info,
            SceneGadgetInfo::mut_deshret_obelisk_gadget_info,
            SceneGadgetInfo::set_deshret_obelisk_gadget_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::CoinCollectOperatorInfo::CoinCollectOperatorInfo>(
            "coin_collect_operator_info",
            SceneGadgetInfo::has_coin_collect_operator_info,
            SceneGadgetInfo::coin_collect_operator_info,
            SceneGadgetInfo::mut_coin_collect_operator_info,
            SceneGadgetInfo::set_coin_collect_operator_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::TrifleGadget::TrifleGadget>(
            "trifle_gadget",
            SceneGadgetInfo::has_trifle_gadget,
            SceneGadgetInfo::trifle_gadget,
            SceneGadgetInfo::mut_trifle_gadget,
            SceneGadgetInfo::set_trifle_gadget,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mark_flag",
            |m: &SceneGadgetInfo| { &m.mark_flag },
            |m: &mut SceneGadgetInfo| { &mut m.mark_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prop_owner_entity_id",
            |m: &SceneGadgetInfo| { &m.prop_owner_entity_id },
            |m: &mut SceneGadgetInfo| { &mut m.prop_owner_entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::PlatformInfo::PlatformInfo>(
            "platform",
            |m: &SceneGadgetInfo| { &m.platform },
            |m: &mut SceneGadgetInfo| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interact_uid_list",
            |m: &SceneGadgetInfo| { &m.interact_uid_list },
            |m: &mut SceneGadgetInfo| { &mut m.interact_uid_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "draft_id",
            |m: &SceneGadgetInfo| { &m.draft_id },
            |m: &mut SceneGadgetInfo| { &mut m.draft_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KHICBPFFAII",
            |m: &SceneGadgetInfo| { &m.KHICBPFFAII },
            |m: &mut SceneGadgetInfo| { &mut m.KHICBPFFAII },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::GadgetPlayInfo::GadgetPlayInfo>(
            "play_info",
            |m: &SceneGadgetInfo| { &m.play_info },
            |m: &mut SceneGadgetInfo| { &mut m.play_info },
        ));
        oneofs.push(scene_gadget_info::Content::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneGadgetInfo>(
            "SceneGadgetInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneGadgetInfo {
    const NAME: &'static str = "SceneGadgetInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gadget_id = is.read_uint32()?;
                },
                16 => {
                    self.group_id = is.read_uint32()?;
                },
                24 => {
                    self.config_id = is.read_uint32()?;
                },
                32 => {
                    self.owner_entity_id = is.read_uint32()?;
                },
                40 => {
                    self.born_type = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.gadget_state = is.read_uint32()?;
                },
                56 => {
                    self.KPKNNJLPMFP = is.read_uint32()?;
                },
                64 => {
                    self.is_show_cutscene = is.read_bool()?;
                },
                72 => {
                    self.authority_peer_id = is.read_uint32()?;
                },
                80 => {
                    self.is_enable_interact = is.read_bool()?;
                },
                88 => {
                    self.CLICILNBKDD = is.read_uint32()?;
                },
                106 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::GatherGadget(is.read_message()?));
                },
                114 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::Worktop(is.read_message()?));
                },
                122 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::ClientGadget(is.read_message()?));
                },
                138 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::Weather(is.read_message()?));
                },
                146 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::AbilityGadget(is.read_message()?));
                },
                154 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::StatueGadget(is.read_message()?));
                },
                162 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::BossChest(is.read_message()?));
                },
                330 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::BlossomChest(is.read_message()?));
                },
                338 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::MpPlayReward(is.read_message()?));
                },
                346 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::GeneralReward(is.read_message()?));
                },
                354 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::OfferingInfo(is.read_message()?));
                },
                362 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::FoundationInfo(is.read_message()?));
                },
                370 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::VehicleInfo(is.read_message()?));
                },
                378 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::ShellInfo(is.read_message()?));
                },
                386 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::ScreenInfo(is.read_message()?));
                },
                474 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::FishPoolInfo(is.read_message()?));
                },
                482 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::CustomGadgetTreeInfo(is.read_message()?));
                },
                490 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::RoguelikeGadgetInfo(is.read_message()?));
                },
                498 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::NightCrowGadgetInfo(is.read_message()?));
                },
                506 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::DeshretObeliskGadgetInfo(is.read_message()?));
                },
                514 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::CoinCollectOperatorInfo(is.read_message()?));
                },
                538 => {
                    self.content = ::std::option::Option::Some(scene_gadget_info::Content::TrifleGadget(is.read_message()?));
                },
                168 => {
                    self.mark_flag = is.read_uint32()?;
                },
                176 => {
                    self.prop_owner_entity_id = is.read_uint32()?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.platform)?;
                },
                194 => {
                    is.read_repeated_packed_uint32_into(&mut self.interact_uid_list)?;
                },
                192 => {
                    self.interact_uid_list.push(is.read_uint32()?);
                },
                200 => {
                    self.draft_id = is.read_uint32()?;
                },
                208 => {
                    self.KHICBPFFAII = is.read_uint32()?;
                },
                802 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.play_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.gadget_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.gadget_id);
        }
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.group_id);
        }
        if self.config_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.config_id);
        }
        if self.owner_entity_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.owner_entity_id);
        }
        if self.born_type != ::protobuf::EnumOrUnknown::new(super::GadgetBornType::GadgetBornType::GADGET_BORN_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(5, self.born_type.value());
        }
        if self.gadget_state != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.gadget_state);
        }
        if self.KPKNNJLPMFP != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.KPKNNJLPMFP);
        }
        if self.is_show_cutscene != false {
            my_size += 1 + 1;
        }
        if self.authority_peer_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.authority_peer_id);
        }
        if self.is_enable_interact != false {
            my_size += 1 + 1;
        }
        if self.CLICILNBKDD != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.CLICILNBKDD);
        }
        if self.mark_flag != 0 {
            my_size += ::protobuf::rt::uint32_size(21, self.mark_flag);
        }
        if self.prop_owner_entity_id != 0 {
            my_size += ::protobuf::rt::uint32_size(22, self.prop_owner_entity_id);
        }
        if let Some(v) = self.platform.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.interact_uid_list {
            my_size += ::protobuf::rt::uint32_size(24, *value);
        };
        if self.draft_id != 0 {
            my_size += ::protobuf::rt::uint32_size(25, self.draft_id);
        }
        if self.KHICBPFFAII != 0 {
            my_size += ::protobuf::rt::uint32_size(26, self.KHICBPFFAII);
        }
        if let Some(v) = self.play_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &scene_gadget_info::Content::GatherGadget(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::Worktop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::ClientGadget(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::Weather(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::AbilityGadget(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::StatueGadget(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::BossChest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::BlossomChest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::MpPlayReward(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::GeneralReward(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::OfferingInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::FoundationInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::VehicleInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::ShellInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::ScreenInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::FishPoolInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::CustomGadgetTreeInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::RoguelikeGadgetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::NightCrowGadgetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::DeshretObeliskGadgetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::CoinCollectOperatorInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &scene_gadget_info::Content::TrifleGadget(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.gadget_id != 0 {
            os.write_uint32(1, self.gadget_id)?;
        }
        if self.group_id != 0 {
            os.write_uint32(2, self.group_id)?;
        }
        if self.config_id != 0 {
            os.write_uint32(3, self.config_id)?;
        }
        if self.owner_entity_id != 0 {
            os.write_uint32(4, self.owner_entity_id)?;
        }
        if self.born_type != ::protobuf::EnumOrUnknown::new(super::GadgetBornType::GadgetBornType::GADGET_BORN_TYPE_NONE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.born_type))?;
        }
        if self.gadget_state != 0 {
            os.write_uint32(6, self.gadget_state)?;
        }
        if self.KPKNNJLPMFP != 0 {
            os.write_uint32(7, self.KPKNNJLPMFP)?;
        }
        if self.is_show_cutscene != false {
            os.write_bool(8, self.is_show_cutscene)?;
        }
        if self.authority_peer_id != 0 {
            os.write_uint32(9, self.authority_peer_id)?;
        }
        if self.is_enable_interact != false {
            os.write_bool(10, self.is_enable_interact)?;
        }
        if self.CLICILNBKDD != 0 {
            os.write_uint32(11, self.CLICILNBKDD)?;
        }
        if self.mark_flag != 0 {
            os.write_uint32(21, self.mark_flag)?;
        }
        if self.prop_owner_entity_id != 0 {
            os.write_uint32(22, self.prop_owner_entity_id)?;
        }
        if let Some(v) = self.platform.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        for v in &self.interact_uid_list {
            os.write_uint32(24, *v)?;
        };
        if self.draft_id != 0 {
            os.write_uint32(25, self.draft_id)?;
        }
        if self.KHICBPFFAII != 0 {
            os.write_uint32(26, self.KHICBPFFAII)?;
        }
        if let Some(v) = self.play_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &scene_gadget_info::Content::GatherGadget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &scene_gadget_info::Content::Worktop(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &scene_gadget_info::Content::ClientGadget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &scene_gadget_info::Content::Weather(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &scene_gadget_info::Content::AbilityGadget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &scene_gadget_info::Content::StatueGadget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &scene_gadget_info::Content::BossChest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &scene_gadget_info::Content::BlossomChest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
                },
                &scene_gadget_info::Content::MpPlayReward(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
                },
                &scene_gadget_info::Content::GeneralReward(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
                },
                &scene_gadget_info::Content::OfferingInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
                },
                &scene_gadget_info::Content::FoundationInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
                },
                &scene_gadget_info::Content::VehicleInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
                },
                &scene_gadget_info::Content::ShellInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
                },
                &scene_gadget_info::Content::ScreenInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
                },
                &scene_gadget_info::Content::FishPoolInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(59, v, os)?;
                },
                &scene_gadget_info::Content::CustomGadgetTreeInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
                },
                &scene_gadget_info::Content::RoguelikeGadgetInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(61, v, os)?;
                },
                &scene_gadget_info::Content::NightCrowGadgetInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(62, v, os)?;
                },
                &scene_gadget_info::Content::DeshretObeliskGadgetInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(63, v, os)?;
                },
                &scene_gadget_info::Content::CoinCollectOperatorInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
                },
                &scene_gadget_info::Content::TrifleGadget(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(67, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneGadgetInfo {
        SceneGadgetInfo::new()
    }

    fn clear(&mut self) {
        self.gadget_id = 0;
        self.group_id = 0;
        self.config_id = 0;
        self.owner_entity_id = 0;
        self.born_type = ::protobuf::EnumOrUnknown::new(super::GadgetBornType::GadgetBornType::GADGET_BORN_TYPE_NONE);
        self.gadget_state = 0;
        self.KPKNNJLPMFP = 0;
        self.is_show_cutscene = false;
        self.authority_peer_id = 0;
        self.is_enable_interact = false;
        self.CLICILNBKDD = 0;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.mark_flag = 0;
        self.prop_owner_entity_id = 0;
        self.platform.clear();
        self.interact_uid_list.clear();
        self.draft_id = 0;
        self.KHICBPFFAII = 0;
        self.play_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneGadgetInfo {
        static instance: SceneGadgetInfo = SceneGadgetInfo {
            gadget_id: 0,
            group_id: 0,
            config_id: 0,
            owner_entity_id: 0,
            born_type: ::protobuf::EnumOrUnknown::from_i32(0),
            gadget_state: 0,
            KPKNNJLPMFP: 0,
            is_show_cutscene: false,
            authority_peer_id: 0,
            is_enable_interact: false,
            CLICILNBKDD: 0,
            mark_flag: 0,
            prop_owner_entity_id: 0,
            platform: ::protobuf::MessageField::none(),
            interact_uid_list: ::std::vec::Vec::new(),
            draft_id: 0,
            KHICBPFFAII: 0,
            play_info: ::protobuf::MessageField::none(),
            content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneGadgetInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneGadgetInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneGadgetInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneGadgetInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SceneGadgetInfo`
pub mod scene_gadget_info {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SceneGadgetInfo.content)
    pub enum Content {
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.gather_gadget)
        GatherGadget(super::super::GatherGadgetInfo::GatherGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.worktop)
        Worktop(super::super::WorktopInfo::WorktopInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.client_gadget)
        ClientGadget(super::super::ClientGadgetInfo::ClientGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.weather)
        Weather(super::super::WeatherInfo::WeatherInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.ability_gadget)
        AbilityGadget(super::super::AbilityGadgetInfo::AbilityGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.statue_gadget)
        StatueGadget(super::super::StatueGadgetInfo::StatueGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.boss_chest)
        BossChest(super::super::BossChestInfo::BossChestInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.blossom_chest)
        BlossomChest(super::super::BlossomChestInfo::BlossomChestInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.mp_play_reward)
        MpPlayReward(super::super::MpPlayRewardInfo::MpPlayRewardInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.general_reward)
        GeneralReward(super::super::GadgetGeneralRewardInfo::GadgetGeneralRewardInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.offering_info)
        OfferingInfo(super::super::OfferingInfo::OfferingInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.foundation_info)
        FoundationInfo(super::super::FoundationInfo::FoundationInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.vehicle_info)
        VehicleInfo(super::super::VehicleInfo::VehicleInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.shell_info)
        ShellInfo(super::super::EchoShellInfo::EchoShellInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.screen_info)
        ScreenInfo(super::super::ScreenInfo::ScreenInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.fish_pool_info)
        FishPoolInfo(super::super::FishPoolInfo::FishPoolInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.custom_gadget_tree_info)
        CustomGadgetTreeInfo(super::super::CustomGadgetTreeInfo::CustomGadgetTreeInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.roguelike_gadget_info)
        RoguelikeGadgetInfo(super::super::RoguelikeGadgetInfo::RoguelikeGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.night_crow_gadget_info)
        NightCrowGadgetInfo(super::super::NightCrowGadgetInfo::NightCrowGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.deshret_obelisk_gadget_info)
        DeshretObeliskGadgetInfo(super::super::DeshretObeliskGadgetInfo::DeshretObeliskGadgetInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.coin_collect_operator_info)
        CoinCollectOperatorInfo(super::super::CoinCollectOperatorInfo::CoinCollectOperatorInfo),
        // @@protoc_insertion_point(oneof_field:SceneGadgetInfo.trifle_gadget)
        TrifleGadget(super::super::TrifleGadget::TrifleGadget),
    }

    impl ::protobuf::Oneof for Content {
    }

    impl ::protobuf::OneofFull for Content {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SceneGadgetInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("content").unwrap()).clone()
        }
    }

    impl Content {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Content>("content")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15SceneGadgetInfo.proto\x1a\x14GadgetBornType.proto\x1a\x16GatherGad\
    getInfo.proto\x1a\x11WorktopInfo.proto\x1a\x16ClientGadgetInfo.proto\x1a\
    \x11WeatherInfo.proto\x1a\x17AbilityGadgetInfo.proto\x1a\x16StatueGadget\
    Info.proto\x1a\x13BossChestInfo.proto\x1a\x16BlossomChestInfo.proto\x1a\
    \x16MpPlayRewardInfo.proto\x1a\x1dGadgetGeneralRewardInfo.proto\x1a\x12O\
    fferingInfo.proto\x1a\x14FoundationInfo.proto\x1a\x11VehicleInfo.proto\
    \x1a\x13EchoShellInfo.proto\x1a\x10ScreenInfo.proto\x1a\x12FishPoolInfo.\
    proto\x1a\x1aCustomGadgetTreeInfo.proto\x1a\x19RoguelikeGadgetInfo.proto\
    \x1a\x19NightCrowGadgetInfo.proto\x1a\x1eDeshretObeliskGadgetInfo.proto\
    \x1a\x1dCoinCollectOperatorInfo.proto\x1a\x12TrifleGadget.proto\x1a\x12P\
    latformInfo.proto\x1a\x14GadgetPlayInfo.proto\"\xfb\x0f\n\x0fSceneGadget\
    Info\x12\x1b\n\tgadget_id\x18\x01\x20\x01(\rR\x08gadgetId\x12\x19\n\x08g\
    roup_id\x18\x02\x20\x01(\rR\x07groupId\x12\x1b\n\tconfig_id\x18\x03\x20\
    \x01(\rR\x08configId\x12&\n\x0fowner_entity_id\x18\x04\x20\x01(\rR\rowne\
    rEntityId\x12,\n\tborn_type\x18\x05\x20\x01(\x0e2\x0f.GadgetBornTypeR\
    \x08bornType\x12!\n\x0cgadget_state\x18\x06\x20\x01(\rR\x0bgadgetState\
    \x12\x20\n\x0bKPKNNJLPMFP\x18\x07\x20\x01(\rR\x0bKPKNNJLPMFP\x12(\n\x10i\
    s_show_cutscene\x18\x08\x20\x01(\x08R\x0eisShowCutscene\x12*\n\x11author\
    ity_peer_id\x18\t\x20\x01(\rR\x0fauthorityPeerId\x12,\n\x12is_enable_int\
    eract\x18\n\x20\x01(\x08R\x10isEnableInteract\x12\x20\n\x0bCLICILNBKDD\
    \x18\x0b\x20\x01(\rR\x0bCLICILNBKDD\x128\n\rgather_gadget\x18\r\x20\x01(\
    \x0b2\x11.GatherGadgetInfoH\0R\x0cgatherGadget\x12(\n\x07worktop\x18\x0e\
    \x20\x01(\x0b2\x0c.WorktopInfoH\0R\x07worktop\x128\n\rclient_gadget\x18\
    \x0f\x20\x01(\x0b2\x11.ClientGadgetInfoH\0R\x0cclientGadget\x12(\n\x07we\
    ather\x18\x11\x20\x01(\x0b2\x0c.WeatherInfoH\0R\x07weather\x12;\n\x0eabi\
    lity_gadget\x18\x12\x20\x01(\x0b2\x12.AbilityGadgetInfoH\0R\rabilityGadg\
    et\x128\n\rstatue_gadget\x18\x13\x20\x01(\x0b2\x11.StatueGadgetInfoH\0R\
    \x0cstatueGadget\x12/\n\nboss_chest\x18\x14\x20\x01(\x0b2\x0e.BossChestI\
    nfoH\0R\tbossChest\x128\n\rblossom_chest\x18)\x20\x01(\x0b2\x11.BlossomC\
    hestInfoH\0R\x0cblossomChest\x129\n\x0emp_play_reward\x18*\x20\x01(\x0b2\
    \x11.MpPlayRewardInfoH\0R\x0cmpPlayReward\x12A\n\x0egeneral_reward\x18+\
    \x20\x01(\x0b2\x18.GadgetGeneralRewardInfoH\0R\rgeneralReward\x124\n\rof\
    fering_info\x18,\x20\x01(\x0b2\r.OfferingInfoH\0R\x0cofferingInfo\x12:\n\
    \x0ffoundation_info\x18-\x20\x01(\x0b2\x0f.FoundationInfoH\0R\x0efoundat\
    ionInfo\x121\n\x0cvehicle_info\x18.\x20\x01(\x0b2\x0c.VehicleInfoH\0R\
    \x0bvehicleInfo\x12/\n\nshell_info\x18/\x20\x01(\x0b2\x0e.EchoShellInfoH\
    \0R\tshellInfo\x12.\n\x0bscreen_info\x180\x20\x01(\x0b2\x0b.ScreenInfoH\
    \0R\nscreenInfo\x125\n\x0efish_pool_info\x18;\x20\x01(\x0b2\r.FishPoolIn\
    foH\0R\x0cfishPoolInfo\x12N\n\x17custom_gadget_tree_info\x18<\x20\x01(\
    \x0b2\x15.CustomGadgetTreeInfoH\0R\x14customGadgetTreeInfo\x12J\n\x15rog\
    uelike_gadget_info\x18=\x20\x01(\x0b2\x14.RoguelikeGadgetInfoH\0R\x13rog\
    uelikeGadgetInfo\x12K\n\x16night_crow_gadget_info\x18>\x20\x01(\x0b2\x14\
    .NightCrowGadgetInfoH\0R\x13nightCrowGadgetInfo\x12Z\n\x1bdeshret_obelis\
    k_gadget_info\x18?\x20\x01(\x0b2\x19.DeshretObeliskGadgetInfoH\0R\x18des\
    hretObeliskGadgetInfo\x12W\n\x1acoin_collect_operator_info\x18@\x20\x01(\
    \x0b2\x18.CoinCollectOperatorInfoH\0R\x17coinCollectOperatorInfo\x124\n\
    \rtrifle_gadget\x18C\x20\x01(\x0b2\r.TrifleGadgetH\0R\x0ctrifleGadget\
    \x12\x1b\n\tmark_flag\x18\x15\x20\x01(\rR\x08markFlag\x12/\n\x14prop_own\
    er_entity_id\x18\x16\x20\x01(\rR\x11propOwnerEntityId\x12)\n\x08platform\
    \x18\x17\x20\x01(\x0b2\r.PlatformInfoR\x08platform\x12*\n\x11interact_ui\
    d_list\x18\x18\x20\x03(\rR\x0finteractUidList\x12\x19\n\x08draft_id\x18\
    \x19\x20\x01(\rR\x07draftId\x12\x20\n\x0bKHICBPFFAII\x18\x1a\x20\x01(\rR\
    \x0bKHICBPFFAII\x12,\n\tplay_info\x18d\x20\x01(\x0b2\x0f.GadgetPlayInfoR\
    \x08playInfoB\t\n\x07contentB\x1b\n\x19emu.grasscutter.net.protob\x06pro\
    to3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(25);
            deps.push(super::GadgetBornType::file_descriptor().clone());
            deps.push(super::GatherGadgetInfo::file_descriptor().clone());
            deps.push(super::WorktopInfo::file_descriptor().clone());
            deps.push(super::ClientGadgetInfo::file_descriptor().clone());
            deps.push(super::WeatherInfo::file_descriptor().clone());
            deps.push(super::AbilityGadgetInfo::file_descriptor().clone());
            deps.push(super::StatueGadgetInfo::file_descriptor().clone());
            deps.push(super::BossChestInfo::file_descriptor().clone());
            deps.push(super::BlossomChestInfo::file_descriptor().clone());
            deps.push(super::MpPlayRewardInfo::file_descriptor().clone());
            deps.push(super::GadgetGeneralRewardInfo::file_descriptor().clone());
            deps.push(super::OfferingInfo::file_descriptor().clone());
            deps.push(super::FoundationInfo::file_descriptor().clone());
            deps.push(super::VehicleInfo::file_descriptor().clone());
            deps.push(super::EchoShellInfo::file_descriptor().clone());
            deps.push(super::ScreenInfo::file_descriptor().clone());
            deps.push(super::FishPoolInfo::file_descriptor().clone());
            deps.push(super::CustomGadgetTreeInfo::file_descriptor().clone());
            deps.push(super::RoguelikeGadgetInfo::file_descriptor().clone());
            deps.push(super::NightCrowGadgetInfo::file_descriptor().clone());
            deps.push(super::DeshretObeliskGadgetInfo::file_descriptor().clone());
            deps.push(super::CoinCollectOperatorInfo::file_descriptor().clone());
            deps.push(super::TrifleGadget::file_descriptor().clone());
            deps.push(super::PlatformInfo::file_descriptor().clone());
            deps.push(super::GadgetPlayInfo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(SceneGadgetInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
